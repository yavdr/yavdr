#!/usr/bin/ruby
require 'socket'
require 'syslog'

module Kernel
	def debug line
		STDOUT.puts "#{caller[0]}: #{line}"
	end
end

class Select
	READ, WRITE, ERROR = 1, 2, 3

	attr_reader :read, :write, :error
	attr_accessor :exit, :exit_on_empty

	def empty?
		@read.empty? && @write.empty? && @error.empty?
	end

	def self.new *p, &e
		r = super *p
		if e
			e.call r
			r.close
		else r
		end
	end

	def initialize timeout = 30
		@read, @write, @error = {}, {}, {}
		@read.default = @write.default = @error.default = lambda{}
		@timeout, @tevent, @exit = timeout, lambda{}, false
	end

	def timeout timeout = nil, &event
		return @timeout  if timeout.nil?
		raise ArgumentError, "Numeric value expected, not: '#{timeout}'"  unless timeout.kind_of? Numeric
		@timeout = timeout
		@tevent = event  if event
		timeout
	end

	def set hook, type = :read, &event
		raise ArgumentError, "This hook isn't supported: '#{hook.inspect}'"  unless hook.kind_of? IO
		raise ArgumentError, "Unexpected Event: '#{event.inspect}'"  unless event.kind_of? Proc
		case type
		when READ, :read    then  @read[ hook] = event
		when WRITE, :write  then @write[ hook] = event
		when ERROR, :error  then @error[ hook] = event
		when nil
			@read[ hook] = event
			@write[ hook] = event
			@error[ hook] = event
		else raise ArgumentError, "Unknown event-type: '#{type}'"
		end
	end

	def del hook, type = nil
		case type
		when READ, :read  then @read.delete hook
		when WRITE, :write  then @write.delete hook
		when ERROR, :error  then @error.delete hook
		when nil
			@read.delete hook
			@write.delete hook
			@error.delete hook
		else raise ArgumentError, "Unknown event-type: '#{type}'"
		end
	end

	def  read_set( hook, &event)  self.set hook,  :read, &event  end
	def write_set( hook, &event)  self.set hook, :write, &event  end
	def error_set( hook, &event)  self.set hook, :error, &event  end
	def  read_del( hook)   @read.delete hook  end
	def write_del( hook)  @write.delete hook  end
	def error_del( hook)  @error.delete hook  end

	def run_once timeout = @timeout
		# Kernel.debug " read = { %s }"%  @read.collect{|k,v|"#{k}=>#{v}"}.join( ", ")
		# Kernel.debug "write = { %s }"% @write.collect{|k,v|"#{k}=>#{v}"}.join( ", ")
		# Kernel.debug "error = { %s }"% @error.collect{|k,v|"#{k}=>#{v}"}.join( ", ")
		r, w, e = Kernel.select( @read.keys, @write.keys, @error.keys, timeout)
		# Kernel.debug "selected: #{[r,w,e].inspect}"
		return @tevent.call  if r.nil?
		r.each do |h|   @read[ h].call h, :read   end
		w.each do |h|  @write[ h].call h, :write  end
		e.each do |h|  @error[ h].call h, :error  end
	end

	def run
		self.run_once  until @exit || (@exit_on_empty && self.empty?)
	end
end

class Select::Socket
	attr_reader :select, :sock, :bufsize, :parent

	def initialize opts
		self.init opts
		@select.read_set @sock, &method( :event_read)
		@select.error_set @sock, &method( :event_error)
	end

	def init opts
		@select  = opts[ :select]  || Select.new
		@sock    = opts[ :sock]    || raise( ArgumentError, "need sock")
		@bufsize = opts[ :bufsize] || 4096
		@parent  = opts[ :parent]  || nil
		self.delimiter = opts[ :delimiter] || $/
		@linebuf, @writebuf = "", ""
	end

	def delimiter= delimiter
		@delimiter = case delimiter
			when Regexp  then Regexp.new "^.*?"+delimiter.source
			when Fixnum, Bignum  then /^.{#{delimiter}}/
			else Regexp.new "^.*?"+Regexp.quote( delimiter.to_s)
			end
	end

	def write str
		e = @writebuf.empty?
		@writebuf += str
		@select.write_set @sock, &method( :event_write)  if e
	end
	alias :print :write
	alias :<< :write
	
	def puts str
		self.write "#{str}\n"
	end

	def close
		@select.del @sock
		@sock.close
		@parent.event_client_closed self  if @parent.respond_to? :event_client_closed
	rescue IOError
	end

	def event_line line
	end

	def event_read sock = @sock, event = :read
		@linebuf += sock.readpartial @bufsize
		while r = @linebuf.slice!( @delimiter)
			self.event_line r
		end
	rescue EOFError
		self.event_eof sock
	rescue Errno::EPIPE => e
		self.event_errno e, sock, event
	rescue IOError
		self.event_ioerror sock, event
	rescue Errno::ECONNRESET => e
		self.event_errno e, sock, event
	end

	def event_write sock = @sock, event = :write
		@writebuf.slice! 0...sock.syswrite( @writebuf)
		@select.write_del sock if @writebuf.empty?
		@writebuf
	rescue IOError
		@select.del @sock
		@writebuf
	end

	def event_eof sock = @sock
		self.close
	end

	def event_errno errno, sock = @sock, event = :error
		# Kernel.debug "ERROR '#{event}' IN #{self}: #{errno.inspect}!"
		self.close
	end

	def event_error sock = @sock, event = :error
		# Kernel.debug "ERROR '#{event}' IN #{self}!"
		self.close
	end

	def event_ioerror sock = @sock, event = :error
		# Kernel.debug "ERROR '#{event}' IN #{self}"
	end

	def closed?
		@sock.closed?
	end
end

class Select::Server
	attr_reader :select, :clientclass

	def initialize opts
		raise "You can't use this class directly. Create a new class and include this Server-class"  if self.class.superclass == Object
		init opts
		select.read_set @sock, &self.method( :event_conn)
	end

	def init opts
		@sock = opts[ :sock] || raise( ArgumentError, "need sock")
		@select = opts[ :select] || Select.new
		@clientclass = opts[ :clientclass] || Select::Socket
		@clients = []
	end

	def run
		# Kernel.debug "Server: run"
		@select.run
		# Kernel.debug "Server: stopped"
	end

	def delete sock
		@select.del sock
	end

	def event_conn sock = @sock, event = :read
		a = sock.accept
		c = event_new_client a
		if c.kind_of? Hash
			cc = c[ :clientclass] || @clientclass
			h = { :sock => a, :select => @select, :parent => self }.update c
			c = cc.new h
		end
		# Kernel.debug "New client: #{c.inspect}"
		@clients.push c
	end

	def event_error sock = @sock, event = :error
		# Kernel.debug "ERROR IN #{self}!"
	end

	def event_new_client sock
		Hash.new
	end

	def event_client_closed client
		@clients.delete client
	end

	def close
		@select.del @sock
		@sock.close
	rescue IOError
	end

	def clients_close
		@clients.each do |c|
			c.close
		end
	end
end

class SVDRPC <Select::Socket
	def initialize opts
		opts.update( :delimiter => /\r?\n/)
		@vdr = opts[ :vdr] || raise( ArgumentError, "need VDR")
		super opts
		@sock.puts "220 #{ENV["HOSTNAME"]} SVDRP svdrpd 0.0.1; #{Time.now}"
	end

	def event_line line
		if /^\s*quit/i.match line
			self.quit "quit"
		else
			@vdr.push self, line
		end
	end

	def event_write *args
		self.close if super( *args).empty? && @quit
	end

	def quit reason = "unknown reason"
		@sock.close_read
		@select.del @sock, :read
		@quit = true
		puts "221 #{ENV["HOSTNAME"]} closing connection (#{reason})"
	rescue IOError
	end
end

class SVDRPD <Select::Server
	def initialize opts
		@vdr = opts[ :vdr] || raise( ArgumentError, "need VDR")
		super opts
	end

	def event_new_client sock
		{ :vdr => @vdr, :clientclass => SVDRPC }
	end

	def quit reason = "unknown reason"
		self.close
		@clients.each do |i|
			i.quit reason
		end
	end
end

class VDR
	Request = Struct.new :client, :str
	attr_reader :sock, :serv, :port, :select, :firstline

	def initialize host = 'localhost', port = 2001, select = Select.new
		@host, @port, @select = host, port, select
		@quit, @queue = false, []
	end

	def closed?
		@sock.nil? || @sock.closed?
	end

	def disconnect
		@sock.close  unless @sock.nil?
	end
	alias :close :disconnect

	def connect
		@sock = VDR::Socket.new :sock => TCPSocket.new( serv, port), :select => @select, :parent => self
		@answer = FirstLine.new
	rescue Errno::ECONNREFUSED
		retry
	end

	def event_answer line
		# Kernel.debug "@answer=#{@answer}"
		l = /^(\d\d\d)([ -])(.*?)[\n\r]*$/.match line
		if l.nil?
			# Kernel.debug "i don't understand this line: #{line}"
			return
		elsif l[ 1].to_i == 221
		else
			@answer.client.puts l[ 1..-1].to_s
			self.next true if l[ 2] == ' '
		end
	end

	def event_client_closed client
		@queue.unshift @answer  unless @answer.nil?
		@firstline = @sock = nil
		self.next  unless @queue.empty?
	end

	def next clear_answer = false
		# Kernel.debug "@queue = [#{@queue.collect{|i|i.to_s}.join ", "}]; @answer = #{@answer.inspect}"
		@answer = nil  if clear_answer
		return self.close  if @quit
		return @answer  if @answer
		begin
			@answer = @queue.shift
		end  while !@answer.nil? && @answer.client.closed?
		if @answer.nil?
		elsif self.closed?
			@queue.unshift @answer
			self.connect
		else
			@sock.puts @answer.str
		end
		@answer
	end

	def push client, str
		r = Request.new client, str.strip
		raise "Not a valid String: #{r.str.inject}"  if !r.str.kind_of?( String) || r.str.empty?
		@queue.unshift r
		self.next
	end

	def quit
		unless self.closed?
			q = Class.new
			class <<q
				def client; self; end
				def closed?; false; end
				def str; "quit"; end
			end
			@queue.unshift q
			self.next
		end
		@quit = true
		self.closed?
	end
end

class VDR::Socket <Select::Socket
	def initialize opts
		opts.update( :delimiter => /\r?\n/)
		super opts
	end

	def event_line line
		@parent.event_answer line
	end

	def quit
		@sock.puts "quit"
	end
end

class VDR::FirstLine
	attr_reader :line, :client, :str

	def initialize
		@client = self
		@str = nil
	end

	def write line
		@line = line
	end

	alias :print :write
	alias :puts :write
	alias :to_s :line
end

###############################################################################
# debug #######################################################################
###############################################################################
if %W{-D --debug}.include? ARGV[0]
	ARGV.shift
	$DEBUG = true
end
$DEBUG = true  if ENV['DEBUG']

if $DEBUG
	def debug_func c, f
		ff = case f
			when /^(.*)\?$/	then "#{$1}_f"
			when /^(.*)\!$/	then "#{$1}_a"
			when "<<"		then "_s"
			when "+"		then "_p"
			when "-"		then "_m"
			when "@+"		then "_P"
			when "@-"		then "_M"
			else "#{f}_n"
			end
		wf = "__wrapped_#{c.object_id.to_s.sub /^-/, "x"}_#{ff}__".intern
		return "#{c}##{wf} already exists"  if c.instance_methods.include? wf
		pre = "\#{\"%x\"%self.hash.abs}:#{c}##{f}"
		c.class_eval <<-EOF
			alias :#{wf} :#{f}
			def #{f} *args, &e
				ret = if e
						STDERR.puts "==>#{pre} \#{args.collect {|i| i.inspect }.join ", "}, &\#{e.inspect}"
						#{wf} *args, &e
					else
						STDERR.puts "==>#{pre} \#{args.collect {|i| i.inspect }.join ", "}"
						#{wf} *args
					end
				#STDERR.puts "<==#{pre}"
				ret
			rescue
				STDERR.puts "<==#{pre} EXCEPTION: \#{$!.inspect}"
				Kernel.raise
			end
		EOF
	end

	def debug_class c, fs
		c.instance_methods.grep fs do |f|
			debug_func c, f
		end
	end

	debug_class Select, /_set|_del$/
	debug_class Select::Socket, /^event_.*|write|print|init|close$/
	debug_class Select::Server, /^event_.*|close|init$/
	debug_class VDR, /^event_.*|next|push|connect|close|disconnect$/
	debug_class VDR::Socket, /^event_.*|close|init$/
	debug_class SVDRPD, /^event_.*|init$/
	debug_class SVDRPC, /^event_.*|init$/
	debug_class VDR::FirstLine, /^write|print|puts$/
end

###############################################################################
# main ########################################################################
###############################################################################
opts = {
	:vdraddr  => ARGV[0] || 'localhost',
	:vdrport  => ARGV[1] || 2002,
	:servaddr => ARGV[2] || 'localhost',
	:servport => ARGV[3] || 2001
}

Syslog.open 'svdrpd', Syslog::LOG_NDELAY | Syslog::LOG_PERROR,
		Syslog::LOG_DAEMON

begin
	$select = Select.new
	$select.timeout 5*60

	$vdr = VDR.new opts[ :vdraddr], opts[ :vdrport], $select
	$serv = SVDRPD.new :vdr => $vdr, :sock => TCPServer.new( opts[ :servaddr], opts[ :servport]), :select => $select
	$select.exit_on_empty = true

	$serv.run
rescue Object
	Syslog.err "#{$!} (#{$!.class}) -- #{$!.backtrace.join ' -- '}"
	$serv.quit "server shuting down"
	$vdr.quit
	retry
end
