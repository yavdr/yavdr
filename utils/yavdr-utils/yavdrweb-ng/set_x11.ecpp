<%pre>
#include <stdlib.h>
#include <string>
#include <iostream>
#include <fstream>
#include <ctype.h>
extern "C" {
#include <ClearSilver.h>
};

#include "common.h"

extern "C" {
#include <X11/Xlib.h>
#include <string.h> /* memcpy(), strerror() */

//#include "NvCtrlAttributes.h"

#include "NVCtrl/NVCtrl.h"
#include "NVCtrl/NVCtrlLib.h"
}

using namespace std;
</%pre><& authenticate ><%args>
  x11_graphtft = "0";
  x11_dualhead = "0";
  deinterlacer_hd = "";
  deinterlacer_sd = "";
  primary = "";
  secondary = "";

  string display0[];
  string display1[];
  string display2[];  

  string overscan0;
  string overscan1;
  string overscan2;

</%args><%shared>
bool writeDisplayToHDF(HDF *hdf, int id, std::vector<string> display, string overscan) {
    if (display.size() == 3) {
        NEOERR *err = hdf_set_valuef(hdf, "system.x11.display.%i.device=%s"  , id, display[0].c_str());
        if (display[1] == "enabled") {
          err = hdf_set_valuef(hdf, "system.x11.display.%i.mode=nvidia-auto-select", id);
          err = hdf_set_valuef(hdf, "system.x11.display.%i.modeline=", id);
        }
        else
        {
          err = hdf_set_valuef(hdf, "system.x11.display.%i.mode=%s"    , id, display[1].c_str());
          err = hdf_set_valuef(hdf, "system.x11.display.%i.modeline=%s", id, display[2].c_str());
        }
        err = hdf_set_valuef(hdf, "system.x11.display.%i.overscan=%s", id, overscan.c_str());
        
        return true;
    }
    return false;
}

void cleanDisplayInHDF(HDF *hdf, int id) {
    NEOERR *err = hdf_set_valuef(hdf, "system.x11.display.%i.device=", id);
    err = hdf_set_valuef(hdf, "system.x11.display.%i.mode="          , id);
    err = hdf_set_valuef(hdf, "system.x11.display.%i.modeline="      , id);
    err = hdf_set_valuef(hdf, "system.x11.display.%i.overscan="      , id);
}
/*
int write_edid_to_file(string filename, unsigned char *data, int len)
{
    int fd = -1;
    char *dst = (void *) -1;
    char *msg = "";

    fd = open(filename, O_RDWR | O_CREAT | O_TRUNC,
              S_IRUSR | S_IWUSR | S_IRGRP);
    if (fd == -1) {
        msg = "Unable to open file for writing";
        goto fail;
    }

    if (lseek(fd, len - 1, SEEK_SET) == -1) {
        msg = "Unable to set file size";
        goto fail;
    }

    if ((dst = mmap(0, len, PROT_READ | PROT_WRITE,
                    MAP_SHARED, fd, 0)) == (void *) -1) {
        msg = "Unable to map file for copying";
        goto fail;
    }

    memcpy(dst, data, len);

    if (munmap(dst, len) == -1) {
        msg = "Unable to unmap output file";
        goto fail;
    }

    close(fd);

    return TRUE;

 fail:

    if (fd != -1) close(fd);

    return FALSE;

} /* write_edid_to_file() */

</%shared><%cpp>
  string success = "false";
  string msg = "Unspecified error.";
  
  NEOERR *err;
  HDF *hdf = NULL;
  if (((err = hdf_init(&hdf)) != STATUS_OK) || ((err = hdf_read_file(hdf, YAVDRDB)) != STATUS_OK))
  {
    msg = "Failed to reset display settings.";
  }
  else
  {
    err = hdf_set_valuef(hdf, "vdr.deinterlacer.hd.type=%s", deinterlacer_hd.c_str());
    err = hdf_set_valuef(hdf, "vdr.deinterlacer.sd.type=%s", deinterlacer_sd.c_str());

    if (x11_dualhead != "1") {
      err = hdf_set_valuef(hdf, "system.x11.dualhead.enabled=0");
      err = hdf_set_valuef(hdf, "vdr.plugin.graphtft.enabled=0");
      
      // writing primary display
      err = hdf_set_valuef(hdf, "system.x11.display.default=%s", primary.c_str());
      
      if (display0.size() == 3 && primary == display0[0]) {
        writeDisplayToHDF(hdf, 0, display0, overscan0);
      } else if (display1.size() == 3 && primary == display1[0]) {
        writeDisplayToHDF(hdf, 0, display1, overscan1);
      } else if (display2.size() == 3 && primary == display2[0]) {
        writeDisplayToHDF(hdf, 0, display2, overscan2);
      } else {
        cleanDisplayInHDF(hdf, 0);
      }
    }
    else
    {
      err = hdf_set_valuef(hdf, "system.x11.dualhead.enabled=1");
      err = hdf_set_valuef(hdf, "system.x11.display.default=%s", primary.c_str());
      err = hdf_set_valuef(hdf, "vdr.plugin.graphtft.enabled=%s", (x11_graphtft=="1"?"1":"0"));
      
      if (display0.size() == 3 && primary == display0[0]) {
        writeDisplayToHDF(hdf, 0, display0, overscan0);
      } else if (display1.size() == 3 && primary == display1[0]) {
        writeDisplayToHDF(hdf, 0, display1, overscan1);
      } else if (display2.size() == 3 && primary == display2[0]) {
        writeDisplayToHDF(hdf, 0, display2, overscan2);
      } else {
        cleanDisplayInHDF(hdf, 0);
      }
      
      if (secondary == primary) {
        cleanDisplayInHDF(hdf, 1);
        err = hdf_set_valuef(hdf, "system.x11.dualhead.enabled=0");
        err = hdf_set_valuef(hdf, "vdr.plugin.graphtft.enabled=0");
      } else if (display0.size() == 3 && secondary == display0[0]) {
        writeDisplayToHDF(hdf, 1, display0, overscan0);
      } else if (display1.size() == 3 && secondary == display1[0]) {
        writeDisplayToHDF(hdf, 1, display1, overscan1);
      } else if (display2.size() == 3 && secondary == display2[0]) {
        writeDisplayToHDF(hdf, 1, display2, overscan2);
      } else {
        cleanDisplayInHDF(hdf, 1);
      }
    }
    
    // Query PCI-Device
    Display *dpy = XOpenDisplay(NULL);
    
    if (dpy) {
        int pci_bus;
        int pci_device;
        int pci_func;

        int screen = DefaultScreen(dpy);
        if (XNVCTRLIsNvScreen(dpy, screen)) {
            Bool ret;
            ret = XNVCTRLQueryTargetAttribute(dpy,
                                              NV_CTRL_TARGET_TYPE_GPU, 0 /* Just query first GPU */,
                                              0,
                                              NV_CTRL_PCI_BUS,
                                              &pci_bus);
            ret = XNVCTRLQueryTargetAttribute(dpy,
                                              NV_CTRL_TARGET_TYPE_GPU, 0 /* Just query first GPU */,
                                              0,
                                              NV_CTRL_PCI_DEVICE,
                                              &pci_device);
            ret = XNVCTRLQueryTargetAttribute(dpy,
                                              NV_CTRL_TARGET_TYPE_GPU, 0 /* Just query first GPU */,
                                              0,
                                              NV_CTRL_PCI_FUNCTION,
                                              &pci_func);
            err = hdf_set_valuef(hdf, "system.hardware.nvidia.busid=%i:%i:%i", pci_bus, pci_device, pci_func);


            // read EDIDs
            /* check if EDID is available for this display device */


			int num_gpus, i;
			/* Get the number of gpus in the system */
			ret = XNVCTRLQueryTargetCount(dpy, NV_CTRL_TARGET_TYPE_GPU,
					&num_gpus);

			if (ret) {
				int display_devices, len;

				/* display information about all GPUs */
				for (int gpu = 0; gpu < num_gpus; gpu++) {
					int *pData;
					/* X Screens driven by this GPU */
					ret = XNVCTRLQueryTargetBinaryData(dpy,
							NV_CTRL_TARGET_TYPE_GPU,
							gpu, // target_id
							0, // display_mask
							NV_CTRL_BINARY_DATA_XSCREENS_USING_GPU,
							(unsigned char **) &pData,
							&len);

					if (ret) {

						/* Connected Display Devices on X Screen */
						ret = XNVCTRLQueryTargetAttribute(dpy,
								NV_CTRL_TARGET_TYPE_X_SCREEN,
								0, // target_id
								0, // display_mask
								NV_CTRL_CONNECTED_DISPLAYS,
								&display_devices);

						/* List all X Screens on GPU */
						for (int j = 1; j <= pData[0]; j++) {
							screen = pData[j];

							/* List all display devices on this X Screen */
							for (int mask = 1; mask < (1 << 24); mask <<= 1) {
								if (!(display_devices & mask)) {
									continue;
								}
/*
					            int val;
					            ret = NvCtrlGetDisplayAttribute(dpy, display_devices & mask,
					                                            NV_CTRL_EDID_AVAILABLE, &val);
					            if ((ret == NvCtrlSuccess) && (val == NV_CTRL_EDID_AVAILABLE_TRUE)) {
					                ret = NvCtrlGetBinaryAttribute(ctk_edid->handle,
					                                               ctk_edid->display_device_mask,
					                                               NV_CTRL_BINARY_DATA_EDID,
					                                               &data, &len);
					                if (ret == NvCtrlSuccess) {
										write_edid_to_file("/etc/X11/edid.bin",
														   data, len);
					                }
					            } else {
					            	err = hdf_set_valuef(hdf, "system.hardware.nvidia.0.edid=", pci_bus, pci_device, pci_func);
					            }
*/
							}
						}

						XFree(pData);
					}
				}
			} // number of gpus


        }
    }
    if ((err != STATUS_OK) || (err = hdf_write_file(hdf, YAVDRDB)) != STATUS_OK) {
      nerr_log_error(err);
      msg = "Error on hdf_write_file";
    }
    hdf_destroy(&hdf);
    if (err == STATUS_OK) {
      int ret = system("/usr/bin/signal-event graphtft-state-change");
      success = "true";
      msg = "OK. signal-event graphtft-state-change";
    }
  }
</%cpp>{
    success: <$success$>
/*    errors: {
        receiver_id: "<$msg$>"
    }
*/
}
