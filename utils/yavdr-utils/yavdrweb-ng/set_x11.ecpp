<%pre>
#include <stdlib.h>
#include <string>
#include <algorithm>
#include <iostream>
#include <fstream>
#include <ctype.h>
extern "C" {
#include <ClearSilver.h>
};

#include "common.h"

extern "C" {
#include <X11/Xlib.h>
#include <string.h> /* memcpy(), strerror() */

#include "NVCtrl/NVCtrl.h"
#include "NVCtrl/NVCtrlLib.h"
}

using namespace std;
</%pre><& authenticate ><%args>
  x11_graphtft = "0";
  x11_dualhead = "0";
  deinterlacer_hd = "";
  deinterlacer_sd = "";
  primary = "";
  secondary = "";

  string display0; string freq0[];
  string display1; string freq1[];
  string display2; string freq2[];

  string overscan0;
  string overscan1;
  string overscan2;

  string defaultfreq0;
  string defaultfreq1;
  string defaultfreq2;
</%args><%shared>
bool writeDisplayToHDF(HDF *hdf, int id, string display, std::vector<string> modes, string overscan, string defaultfreq) {
    if (modes.size() > 0) {
        NEOERR *err = hdf_set_valuef(hdf, "system.x11.display.%i.device=%s"  , id, display.c_str());

        sort(modes.begin(), modes.end());
        for(int i=0; i < modes.size(); i++) {
          err = hdf_set_valuef(hdf, "system.x11.display.%i.mode.%i=%s", id, i, modes[i].c_str());
        }

        err = hdf_set_valuef(hdf, "system.x11.display.%i.overscan=%s", id, overscan.c_str());
        err = hdf_set_valuef(hdf, "system.x11.display.%i.default=%s", id, defaultfreq.c_str());
        
        return true;
    }
    return false;
}

void cleanDisplayInHDF(HDF *hdf, int id) {
	char buffer[100];
	sprintf(buffer, "system.x11.display.%i", id);
    NEOERR *err = hdf_remove_tree(hdf, buffer);
}


int display_device_mask(string name) {
	if (name == "CRT-0") {
		return (1 << 0);
	} else if (name == "CRT-1") {
		return (1 << 1);
	} else if (name == "CRT-2") {
		return (1 << 2);
	} else if (name == "CRT-3") {
		return (1 << 3);
	} else if (name == "CRT-4") {
		return (1 << 4);
	} else if (name == "CRT-5") {
		return (1 << 5);
	} else if (name == "CRT-6") {
		return (1 << 6);
	} else if (name == "CRT-7") {
		return (1 << 7);
	} else if (name == "TV-0") {
		return (1 << 8);
	} else if (name == "TV-1") {
		return (1 << 9);
	} else if (name == "TV-2") {
		return (1 << 10);
	} else if (name == "TV-3") {
		return (1 << 11);
	} else if (name == "TV-4") {
		return (1 << 12);
	} else if (name == "TV-5") {
		return (1 << 13);
	} else if (name == "TV-6") {
		return (1 << 14);
	} else if (name == "TV-7") {
		return (1 << 15);
	} else if (name == "DFP-0") {
		return (1 << 16);
	} else if (name == "DFP-1") {
		return (1 << 17);
	} else if (name == "DFP-2") {
		return (1 << 18);
	} else if (name == "DFP-3") {
		return (1 << 19);
	} else if (name == "DFP-4") {
		return (1 << 20);
	} else if (name == "DFP-5") {
		return (1 << 21);
	} else if (name == "DFP-6") {
		return (1 << 22);
	} else if (name == "DFP-7") {
		return (1 << 23);
	} else {
		return 0;
	}
}

</%shared><%cpp>
  string success = "false";
  string msg = "Unspecified error.";
  
  NEOERR *err;
  HDF *hdf = NULL;
  if (((err = hdf_init(&hdf)) != STATUS_OK) || ((err = hdf_read_file(hdf, YAVDRDB)) != STATUS_OK))
  {
    msg = "Failed to reset display settings.";
  }
  else
  {
    err = hdf_set_valuef(hdf, "vdr.deinterlacer.hd.type=%s", deinterlacer_hd.c_str());
    err = hdf_set_valuef(hdf, "vdr.deinterlacer.sd.type=%s", deinterlacer_sd.c_str());

    if (x11_dualhead != "1") {
      err = hdf_set_valuef(hdf, "system.x11.dualhead.enabled=0");
      err = hdf_set_valuef(hdf, "vdr.plugin.graphtft.enabled=0");
      
      // writing primary display
      err = hdf_set_valuef(hdf, "system.x11.display.default=%s", primary.c_str());
      
      cleanDisplayInHDF(hdf, 0);
      if (freq0.size() > 0 && primary == display0) {
        writeDisplayToHDF(hdf, 0, display0, freq0, overscan0, defaultfreq0);
      } else if (freq1.size() > 0 && primary == display1) {
        writeDisplayToHDF(hdf, 0, display1, freq1, overscan1, defaultfreq1);
      } else if (freq2.size() > 0 && primary == display2) {
        writeDisplayToHDF(hdf, 0, display2, freq2, overscan2, defaultfreq2);
      }
    }
    else
    {
      err = hdf_set_valuef(hdf, "system.x11.dualhead.enabled=1");
      err = hdf_set_valuef(hdf, "system.x11.display.default=%s", primary.c_str());
      err = hdf_set_valuef(hdf, "vdr.plugin.graphtft.enabled=%s", (x11_graphtft=="1"?"1":"0"));
      
      cleanDisplayInHDF(hdf, 0);
      if (freq0.size() > 0 && primary == display0) {
        writeDisplayToHDF(hdf, 0, display0, freq0, overscan0, defaultfreq0);
      } else if (freq1.size() > 0 && primary == display1) {
        writeDisplayToHDF(hdf, 0, display1, freq1, overscan1, defaultfreq1);
      } else if (freq2.size() > 0 && primary == display2) {
        writeDisplayToHDF(hdf, 0, display2, freq2, overscan2, defaultfreq2);
      }
      
      cleanDisplayInHDF(hdf, 1);
      if (primary != "" && secondary == primary) {
        err = hdf_set_valuef(hdf, "system.x11.dualhead.enabled=0");
        err = hdf_set_valuef(hdf, "vdr.plugin.graphtft.enabled=0");
      } else if (freq0.size() > 0 && secondary == display0) {
        writeDisplayToHDF(hdf, 1, display0, freq0, overscan0, defaultfreq0);
      } else if (freq1.size() > 0 && secondary == display1) {
        writeDisplayToHDF(hdf, 1, display1, freq1, overscan1, defaultfreq1);
      } else if (freq2.size() > 0 && secondary == display2) {
        writeDisplayToHDF(hdf, 1, display2, freq2, overscan2, defaultfreq2);
      }
    }
    
    // Query PCI-Device
    Display *dpy = XOpenDisplay(NULL);
    
    if (dpy) {
        int pci_bus;
        int pci_device;
        int pci_func;

        int screen = DefaultScreen(dpy);
        if (XNVCTRLIsNvScreen(dpy, screen)) {
            Bool ret;
            ret = XNVCTRLQueryTargetAttribute(dpy,
                                              NV_CTRL_TARGET_TYPE_GPU, 0 /* Just query first GPU */,
                                              0,
                                              NV_CTRL_PCI_BUS,
                                              &pci_bus);
            ret = XNVCTRLQueryTargetAttribute(dpy,
                                              NV_CTRL_TARGET_TYPE_GPU, 0 /* Just query first GPU */,
                                              0,
                                              NV_CTRL_PCI_DEVICE,
                                              &pci_device);
            ret = XNVCTRLQueryTargetAttribute(dpy,
                                              NV_CTRL_TARGET_TYPE_GPU, 0 /* Just query first GPU */,
                                              0,
                                              NV_CTRL_PCI_FUNCTION,
                                              &pci_func);
            err = hdf_set_valuef(hdf, "system.hardware.nvidia.busid=%i:%i:%i", pci_bus, pci_device, pci_func);


            // read EDIDs
            /* check if EDID is available for this display device */


			int num_gpus, i;
			/* Get the number of gpus in the system */
			ret = XNVCTRLQueryTargetCount(dpy, NV_CTRL_TARGET_TYPE_GPU,
					&num_gpus);

			if (ret) {
				int display_devices, len;

				/* display information about all GPUs */
				for (int gpu = 0; gpu < num_gpus; gpu++) {
					int *pData;
					/* X Screens driven by this GPU */
					ret = XNVCTRLQueryTargetBinaryData(dpy,
							NV_CTRL_TARGET_TYPE_GPU,
							gpu, // target_id
							0, // display_mask
							NV_CTRL_BINARY_DATA_XSCREENS_USING_GPU,
							(unsigned char **) &pData,
							&len);

					if (ret) {
						/* Connected Display Devices on X Screen */
						ret = XNVCTRLQueryTargetAttribute(dpy,
								NV_CTRL_TARGET_TYPE_X_SCREEN,
								0, // target_id
								0, // display_mask
								NV_CTRL_CONNECTED_DISPLAYS,
								&display_devices);

						/* List all X Screens on GPU */
						for (int j = 1; j <= pData[0]; j++) {
							screen = pData[j];
							int enabled_devices;

							/* Enabled Display Devices on X Screen */
							ret = XNVCTRLQueryTargetAttribute(dpy,
									NV_CTRL_TARGET_TYPE_X_SCREEN,
									screen, // target_id
									0, // display_mask
									NV_CTRL_ENABLED_DISPLAYS,
									&enabled_devices);
							//printf("   Display Device Mask (Enabled)   : 0x%08x\n",
							//enabled_devices);

							// edid for primary device
							int mask = display_device_mask(primary);
							if ((enabled_devices & mask)) {
								int val;
								char *data;
								ret = XNVCTRLQueryTargetAttribute(dpy,
										NV_CTRL_TARGET_TYPE_X_SCREEN,
										screen,
										mask,
										NV_CTRL_EDID_AVAILABLE,
										&val);
								ret = 1;
								if (ret && (val == NV_CTRL_EDID_AVAILABLE_TRUE)) {
									ret = XNVCTRLQueryTargetBinaryData(dpy,
											NV_CTRL_TARGET_TYPE_X_SCREEN,
											screen, // target_id
											mask, // display_mask
											NV_CTRL_BINARY_DATA_EDID,
											(unsigned char **) &data,
											&len);
									if (ret) {
										ofstream myFile ("/etc/X11/edid.0.yavdr" , ios::out | ios::binary);
										if (myFile) {
											myFile.write (data, len);
											myFile.close();
											err = hdf_set_valuef(hdf, "system.hardware.nvidia.0.edid=1");
										} else {
											err = hdf_set_valuef(hdf, "system.hardware.nvidia.0.edid=0");
										}
									}
								} else {
									err = hdf_remove_tree(hdf, "system.hardware.nvidia.0.edid");
								}
							}


							// edid for secondary device
							mask = display_device_mask(secondary);
							if ((enabled_devices & mask)) {
								int val;
								char *data;
								ret = XNVCTRLQueryTargetAttribute(dpy,
										NV_CTRL_TARGET_TYPE_X_SCREEN,
										screen,
										mask,
										NV_CTRL_EDID_AVAILABLE,
										&val);
								ret = 1;
								if (ret && (val == NV_CTRL_EDID_AVAILABLE_TRUE)) {
									ret = XNVCTRLQueryTargetBinaryData(dpy,
											NV_CTRL_TARGET_TYPE_X_SCREEN,
											screen, // target_id
											mask, // display_mask
											NV_CTRL_BINARY_DATA_EDID,
											(unsigned char **) &data,
											&len);
									if (ret) {
										ofstream myFile ("/etc/X11/edid.1.yavdr" , ios::out | ios::binary);
										if (myFile) {
											myFile.write (data, len);
											myFile.close();
											err = hdf_set_valuef(hdf, "system.hardware.nvidia.1.edid=1");
										} else {
											err = hdf_set_valuef(hdf, "system.hardware.nvidia.1.edid=0");
										}
									}
								} else {
									err = hdf_remove_tree(hdf, "system.hardware.nvidia.1.edid");
								}
							}
						}

						XFree(pData);
					}
				}
			} // number of gpus
        }

        XCloseDisplay(dpy);
    }
    if ((err != STATUS_OK) || (err = hdf_write_file(hdf, YAVDRDB)) != STATUS_OK) {
      nerr_log_error(err);
      msg = "Error on hdf_write_file";
    }
    hdf_destroy(&hdf);
    if (err == STATUS_OK) {
      int ret = system("/usr/bin/signal-event graphtft-state-change");
      success = "true";
      msg = "OK. signal-event graphtft-state-change";
    }
  }
</%cpp>{
    success: <$success$>
/*    errors: {
        receiver_id: "<$msg$>"
    }
*/
}
