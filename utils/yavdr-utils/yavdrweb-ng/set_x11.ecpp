<%pre>
#include <stdlib.h>
#include <string>
#include <iostream>
#include <fstream>
#include <ctype.h>
extern "C" {
#include <ClearSilver.h>
};

#include "common.h"

extern "C" {
#include <X11/Xlib.h>
#include <string.h> /* memcpy(), strerror() */

#include "NVCtrl/NVCtrl.h"
#include "NVCtrl/NVCtrlLib.h"
}

using namespace std;
</%pre><& authenticate ><%args>
  x11_graphtft = "0";
  x11_dualhead = "0";
  deinterlacer_hd = "";
  deinterlacer_sd = "";
  primary = "";
  secondary = "";

  string display0[];
  string display1[];
  string display2[];  

  string overscan0;
  string overscan1;
  string overscan2;

</%args><%shared>
bool writeDisplayToHDF(HDF *hdf, int id, std::vector<string> display, string overscan) {
    if (display.size() == 3) {
        NEOERR *err = hdf_set_valuef(hdf, "system.x11.display.%i.device=%s"  , id, display[0].c_str());
        if (display[1] == "enabled") {
          err = hdf_set_valuef(hdf, "system.x11.display.%i.mode=nvidia-auto-select", id);
          err = hdf_set_valuef(hdf, "system.x11.display.%i.modeline=", id);
        }
        else
        {
          err = hdf_set_valuef(hdf, "system.x11.display.%i.mode=%s"    , id, display[1].c_str());
          err = hdf_set_valuef(hdf, "system.x11.display.%i.modeline=%s", id, display[2].c_str());
        }
        err = hdf_set_valuef(hdf, "system.x11.display.%i.overscan=%s", id, overscan.c_str());
        
        return true;
    }
    return false;
}

void cleanDisplayInHDF(HDF *hdf, int id) {
    NEOERR *err = hdf_set_valuef(hdf, "system.x11.display.%i.device=", id);
    err = hdf_set_valuef(hdf, "system.x11.display.%i.mode="          , id);
    err = hdf_set_valuef(hdf, "system.x11.display.%i.modeline="      , id);
    err = hdf_set_valuef(hdf, "system.x11.display.%i.overscan="      , id);
}

</%shared><%cpp>
  string success = "false";
  string msg = "Unspecified error.";
  
  NEOERR *err;
  HDF *hdf = NULL;
  if (((err = hdf_init(&hdf)) != STATUS_OK) || ((err = hdf_read_file(hdf, YAVDRDB)) != STATUS_OK))
  {
    msg = "Failed to reset display settings.";
  }
  else
  {
    err = hdf_set_valuef(hdf, "vdr.deinterlacer.hd.type=%s", deinterlacer_hd.c_str());
    err = hdf_set_valuef(hdf, "vdr.deinterlacer.sd.type=%s", deinterlacer_sd.c_str());

    if (x11_dualhead != "1") {
      err = hdf_set_valuef(hdf, "system.x11.dualhead.enabled=0");
      err = hdf_set_valuef(hdf, "vdr.plugin.graphtft.enabled=0");
      
      // writing primary display
      err = hdf_set_valuef(hdf, "system.x11.display.default=%s", primary.c_str());
      
      if (display0.size() == 3 && primary == display0[0]) {
        writeDisplayToHDF(hdf, 0, display0, overscan0);
      } else if (display1.size() == 3 && primary == display1[0]) {
        writeDisplayToHDF(hdf, 0, display1, overscan1);
      } else if (display2.size() == 3 && primary == display2[0]) {
        writeDisplayToHDF(hdf, 0, display2, overscan2);
      } else {
        cleanDisplayInHDF(hdf, 0);
      }
    }
    else
    {
      err = hdf_set_valuef(hdf, "system.x11.dualhead.enabled=1");
      err = hdf_set_valuef(hdf, "system.x11.display.default=%s", primary.c_str());
      err = hdf_set_valuef(hdf, "vdr.plugin.graphtft.enabled=%s", (x11_graphtft=="1"?"1":"0"));
      
      if (display0.size() == 3 && primary == display0[0]) {
        writeDisplayToHDF(hdf, 0, display0, overscan0);
      } else if (display1.size() == 3 && primary == display1[0]) {
        writeDisplayToHDF(hdf, 0, display1, overscan1);
      } else if (display2.size() == 3 && primary == display2[0]) {
        writeDisplayToHDF(hdf, 0, display2, overscan2);
      } else {
        cleanDisplayInHDF(hdf, 0);
      }
      
      if (primary != "" && secondary == primary) {
        cleanDisplayInHDF(hdf, 1);
        err = hdf_set_valuef(hdf, "system.x11.dualhead.enabled=0");
        err = hdf_set_valuef(hdf, "vdr.plugin.graphtft.enabled=0");
      } else if (display0.size() == 3 && secondary == display0[0]) {
        writeDisplayToHDF(hdf, 1, display0, overscan0);
      } else if (display1.size() == 3 && secondary == display1[0]) {
        writeDisplayToHDF(hdf, 1, display1, overscan1);
      } else if (display2.size() == 3 && secondary == display2[0]) {
        writeDisplayToHDF(hdf, 1, display2, overscan2);
      } else {
        cleanDisplayInHDF(hdf, 1);
      }
    }
    
    // Query PCI-Device
    Display *dpy = XOpenDisplay(NULL);
    
    if (dpy) {
        int pci_bus;
        int pci_device;
        int pci_func;

        int screen = DefaultScreen(dpy);
        if (XNVCTRLIsNvScreen(dpy, screen)) {
            Bool ret;
            ret = XNVCTRLQueryTargetAttribute(dpy,
                                              NV_CTRL_TARGET_TYPE_GPU, 0 /* Just query first GPU */,
                                              0,
                                              NV_CTRL_PCI_BUS,
                                              &pci_bus);
            ret = XNVCTRLQueryTargetAttribute(dpy,
                                              NV_CTRL_TARGET_TYPE_GPU, 0 /* Just query first GPU */,
                                              0,
                                              NV_CTRL_PCI_DEVICE,
                                              &pci_device);
            ret = XNVCTRLQueryTargetAttribute(dpy,
                                              NV_CTRL_TARGET_TYPE_GPU, 0 /* Just query first GPU */,
                                              0,
                                              NV_CTRL_PCI_FUNCTION,
                                              &pci_func);
            err = hdf_set_valuef(hdf, "system.hardware.nvidia.busid=%i:%i:%i", pci_bus, pci_device, pci_func);


            // read EDIDs
            /* check if EDID is available for this display device */


			int num_gpus, i;
			/* Get the number of gpus in the system */
			ret = XNVCTRLQueryTargetCount(dpy, NV_CTRL_TARGET_TYPE_GPU,
					&num_gpus);

			if (ret) {
				int display_devices, len;

				/* display information about all GPUs */
				for (int gpu = 0; gpu < num_gpus; gpu++) {
					int *pData;
					/* X Screens driven by this GPU */
					ret = XNVCTRLQueryTargetBinaryData(dpy,
							NV_CTRL_TARGET_TYPE_GPU,
							gpu, // target_id
							0, // display_mask
							NV_CTRL_BINARY_DATA_XSCREENS_USING_GPU,
							(unsigned char **) &pData,
							&len);

					if (ret) {

						/* Connected Display Devices on X Screen */
						ret = XNVCTRLQueryTargetAttribute(dpy,
								NV_CTRL_TARGET_TYPE_X_SCREEN,
								0, // target_id
								0, // display_mask
								NV_CTRL_CONNECTED_DISPLAYS,
								&display_devices);

						/* List all X Screens on GPU */
						for (int j = 1; j <= pData[0]; j++) {
							screen = pData[j];
							int enabled_devices;

							/* Enabled Display Devices on X Screen */
							ret = XNVCTRLQueryTargetAttribute(dpy,
									NV_CTRL_TARGET_TYPE_X_SCREEN,
									screen, // target_id
									0, // display_mask
									NV_CTRL_ENABLED_DISPLAYS,
									&enabled_devices);
							//printf("   Display Device Mask (Enabled)   : 0x%08x\n",
							//enabled_devices);

							/* List all display devices on this X Screen */
							for (int mask = 1; mask < (1 << 24); mask <<= 1) {
								if (!(enabled_devices & mask)) {
									continue;
								}
								int val;
								char *data;
								ret = XNVCTRLQueryTargetAttribute(dpy,
										NV_CTRL_TARGET_TYPE_X_SCREEN,
										screen,
										mask,
										NV_CTRL_EDID_AVAILABLE,
										&val);
								ret = 1;
								if (ret && (val == NV_CTRL_EDID_AVAILABLE_TRUE)) {
									//printf("edid avail\n");
									ret = XNVCTRLQueryTargetBinaryData(dpy,
											NV_CTRL_TARGET_TYPE_X_SCREEN,
											screen, // target_id
											mask, // display_mask
											NV_CTRL_BINARY_DATA_EDID,
											(unsigned char **) &data,
											&len);
									if (ret) {
										//printf("writing edid\n");
										char filename[100];
										sprintf(filename, "/etc/X11/edid.%i.yavdr", screen);
										ofstream myFile (filename , ios::out | ios::binary);
										myFile.write (data, len);
										myFile.close();
										err = hdf_set_valuef(hdf, "system.hardware.nvidia.%i.edid=true", screen);
									} else {
										//printf("not writing edid\n");
									}
								} else {
									//printf("edid not avail %i %i\n", ret, val);
									err = hdf_remove_tree(hdf, "system.hardware.nvidia.%i.edid");
								}
							}
						}

						XFree(pData);
					}
				}
			} // number of gpus


        }
    }
    if ((err != STATUS_OK) || (err = hdf_write_file(hdf, YAVDRDB)) != STATUS_OK) {
      nerr_log_error(err);
      msg = "Error on hdf_write_file";
    }
    hdf_destroy(&hdf);
    if (err == STATUS_OK) {
      int ret = system("/usr/bin/signal-event graphtft-state-change");
      success = "true";
      msg = "OK. signal-event graphtft-state-change";
    }
  }
</%cpp>{
    success: <$success$>
/*    errors: {
        receiver_id: "<$msg$>"
    }
*/
}
