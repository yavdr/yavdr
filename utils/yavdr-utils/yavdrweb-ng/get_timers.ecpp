<%pre>
#include <stdio.h>
#include <time.h>
#include <string>
#include <jsoncpp/json.h>
#include <time.h>

extern "C" {
#include <svdrp.h>
}

using namespace std;
</%pre><& authenticate ><%cpp>
	reply.setHeader ("Cache-Control", "no-cache", true);
	//reply.setHeader ("Content-Type", "application/json", true);

	Json::Value json;

	json["metaData"]["root"]  = "data";
	json["metaData"]["idProperty"]  = "id";
	json["metaData"]["totalProperty"]  = "total";

	json["metaData"]["fields"][0u]["name"] = "id";
	json["metaData"]["fields"][0u]["type"] = "integer";
	json["metaData"]["fields"][1u] = "name";
	json["metaData"]["fields"][2u] = "information";
	json["metaData"]["fields"][3u]["name"] = "length";
	json["metaData"]["fields"][3u]["type"] = "integer";

	svdrp_t *svdrp;

	svdrp = svdrp_open("127.0.0.1", 6419, SVDRP_DEFAULT_TIMEOUT, SVDRP_MSG_VERBOSE);
	if(svdrp_is_connected(svdrp)) {
		int convert_time = 0;
		struct tm tm = {0};
		svdrp_timer_t timer;
		int timer_id = 0;
		int ret = 0;
		char time_str[256];
		int option = -1;

		int i = 0;

		while (ret = svdrp_get_timer(svdrp, timer_id+1, &timer) == SVDRP_OK) {
			Json::Value timerStore;

			timerStore["id"] = timer.id;
			timerStore["channel"] = timer.channel;
			timerStore["first_date"] = timer.first_date;
			timerStore["start"] = timer.start;
			timerStore["stop"] = timer.stop;
			timerStore["repeating"] = timer.repeating;
			timerStore["is_active"] = timer.is_active;
			timerStore["is_recording"] = timer.is_recording;
			timerStore["is_instant"] = timer.is_instant;
			timerStore["use_vps"] = timer.use_vps;
			timerStore["priority"] = timer.priority;
			timerStore["lifetime"] = timer.lifetime;
			timerStore["file"] = timer.file;
			timerStore["data"] = timer.data;

			json["data"][i++] = timerStore;
			timer_id++;
		}
		svdrp_close(svdrp);
		json["total"] = timer_id;
	} else {
		json["total"] = 0;
		json["data"] = NULL;
	}

	reply.out() << json;

</%cpp>
