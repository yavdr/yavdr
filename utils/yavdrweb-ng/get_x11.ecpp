<%pre>
#include <string>
#include <ctype.h>
#include <ClearSilver.h>
#include "../common.h"

#include <cxxtools/loginit.h>
#include <cxxtools/log.h>

extern "C" {
#include <X11/Xlib.h>

#include "NVCtrl.h"
#include "NVCtrlLib.h"
}

char *display_device_name(int mask);

using namespace std;
</%pre><& authenticate ><%args>
display;
</%args><%shared>
void Tokenize(const string& str,
                       vector<string>& tokens,
                       const string& delimiters = " ")
{
     tokens.clear();
     // Skip delimiters at beginning.
     string::size_type lastPos = str.find_first_not_of(delimiters, 0);
     // Find first "non-delimiter".
     string::size_type pos     = str.find_first_of(delimiters, lastPos);

     while (string::npos != pos || string::npos != lastPos)
     {
         // Found a token, add it to the vector.
         tokens.push_back(str.substr(lastPos, pos - lastPos));
         // Skip delimiters.  Note the "not_of"
         lastPos = str.find_first_not_of(delimiters, pos);
         // Find next "non-delimiter"
         pos = str.find_first_of(delimiters, lastPos);
     }
}

string display_device_name(int mask) {
    switch (mask) {
       case (1 <<  0): return "CRT-0"; break;
       case (1 <<  1): return "CRT-1"; break;
       case (1 <<  2): return "CRT-2"; break;
       case (1 <<  3): return "CRT-3"; break;
       case (1 <<  4): return "CRT-4"; break;
       case (1 <<  5): return "CRT-5"; break;
       case (1 <<  6): return "CRT-6"; break;
       case (1 <<  7): return "CRT-7"; break;

       case (1 <<  8): return "TV-0"; break;
       case (1 <<  9): return "TV-1"; break;
       case (1 << 10): return "TV-2"; break;
       case (1 << 11): return "TV-3"; break;
       case (1 << 12): return "TV-4"; break;
       case (1 << 13): return "TV-5"; break;
       case (1 << 14): return "TV-6"; break;
       case (1 << 15): return "TV-7"; break;

       case (1 << 16): return "DFP-0"; break;
       case (1 << 17): return "DFP-1"; break;
       case (1 << 18): return "DFP-2"; break;
       case (1 << 19): return "DFP-3"; break;
       case (1 << 20): return "DFP-4"; break;
       case (1 << 21): return "DFP-5"; break;
       case (1 << 22): return "DFP-6"; break;
       case (1 << 23): return "DFP-7"; break;
       default: return "Unknown";
     }
}
</%shared><%cpp>
  reply.setHeader ("Cache-Control", "no-cache", false);
  reply.setHeader ("Content-Type", "application/json", false);
  
  log_init();
  
  HDF *hdf = NULL;
  NEOERR *err;
  
  string dualhead_enabled = "";
  string graphtft_enabled = "";
  
  //get current lirc settings from database
  if (((err = hdf_init(&hdf)) != STATUS_OK) || ((err = hdf_read_file(hdf, YAVDRDB)) != STATUS_OK))
  {
    nerr_log_error(err);
  }
  else
  {
    dualhead_enabled = hdf_get_value(hdf, "system.x11.dualhead.enabled", "0");
    if (dualhead_enabled == "") {
        dualhead_enabled = "0";
    }
    graphtft_enabled = hdf_get_value(hdf, "vdr.plugin.graphtft.enabled", "0");
    if (graphtft_enabled == "") {
        graphtft_enabled = "0";
    }
    
    Display *dpy;
    Bool ret;
    int screen, display_devices, mask, len, j;
    char *str, *start;
    
    string _s;

    int nDisplayDevice;
    
    reply.out() << "{\n"
              << "  \"system\" : {\n"
              << "    \"x11\" : {\n"
              << "      \"dualhead\" : {\n"
              << "         \"enabled\" : " + dualhead_enabled + "\n"
              << "        }\n";
    
    /*
     * Open a display connection, and make sure the NV-CONTROL X
     * extension is present on the screen we want to use.
     */

    dpy = XOpenDisplay((display == ""?NULL:display.c_str()));
    
    if (dpy) {
        screen = DefaultScreen(dpy);

        if (XNVCTRLIsNvScreen(dpy, screen)) {
           ret = XNVCTRLQueryAttribute(dpy, screen, 0,
                     NV_CTRL_CONNECTED_DISPLAYS, &display_devices);

           if (ret) {
             reply.out() << ","
                         << "    \"displays\" : [\n";
             nDisplayDevice = 0;
             for (mask = 1; mask < (1 << 24); mask <<= 1) {
                 if (display_devices & mask) {
                     XNVCTRLQueryStringAttribute(dpy, screen, mask,
                                                 NV_CTRL_STRING_DISPLAY_DEVICE_NAME,
                                                 &str);
                     
                     string name = string(str);
                     string display_device = display_device_name(mask);
                     
                     if (nDisplayDevice++ != 0)
                     {
                        reply.out() << "      ,\n";
                     }
                     
                     reply.out()  << "      {\n"
                                  << "        \"name\" : \"";
                     reply.sout() << name;
                     reply.out()  << "\",\n"
                                  << "        \"devicename\" : \"";
                     reply.sout() << display_device;
                     XFree(str);
                     
                     reply.out()  << "\",\n"
                                  << "        \"current_modeline\" : {\n";
                     ret = XNVCTRLQueryStringAttribute(dpy, screen, mask,
                                                       NV_CTRL_STRING_CURRENT_MODELINE,
                                                       &str);
                
                     if (ret) {
                         _s = string(str);
                         vector<string> tokens, parts;
                         tokens.clear();
                         Tokenize(_s, parts, ":");
                         Tokenize(parts[parts.size()-1], tokens);
                         
                         reply.out()  << "        \"id\" : \"";
                         reply.sout() << tokens[0].substr(1, tokens[0].length()-2);
                         reply.out()  << "\",\n"
                                      << "        \"modeline\" : \"";
                                      
                         reply.sout() << parts[parts.size()-1];
                         reply.out()  << "\",\n"
                                      << "        \"x\" : \"";
                                      
                         reply.sout() << tokens[2];
                         reply.out()  << "\",\n"
                                      << "        \"y\" : \"";
                                      
                         reply.sout() << tokens[6];
                         reply.out()  << "\"\n";
                         XFree(str);
                     }
                     else
                     {
                         log_error("Failed to query current ModeLine.\n\n");
                     }

                     /* query for modelines */
                     reply.out()  << "},\n"
                                  << "        \"modelines\" : [";
                                  
                     ret = XNVCTRLQueryBinaryData(dpy, screen, mask,
                                                  NV_CTRL_BINARY_DATA_MODELINES,
                                                  (unsigned char **) &str, &len);
                        
                     if (ret) {
        
                         /*
                          * the returned data is in the form:
                          *
                          *  "ModeLine 1\0ModeLine 2\0ModeLine 3\0Last ModeLine\0\0"
                          *
                          * so walk from one "\0" to the next to print each ModeLine.
                          */
                         start = str;
                         ret = true; // first modeline
                         for (j = 0; j < len; j++) {
                           if (str[j] == '\0' && start[0] != '\0') {
                             if (!ret)
                             {
                               reply.out()  << ",";
                             }
                             else
                             {
                               ret = false;
                             }
                             
                             _s = string(start);
                             vector<string> tokens;
                             vector<string> parts;
                             Tokenize(_s, parts, ":");
                             Tokenize(parts[parts.size()-1], tokens);
                             
                             reply.out()  << "{\n"
                                          << "        \"id\" : \"";
                             reply.sout() << tokens[0].substr(1, tokens[0].length()-2);
                             reply.out()  << "\",\n"
                                          << "        \"modeline\" : \"";
                                          
                             reply.sout() << parts[parts.size()-1];
                             reply.out()  << "\",\n"
                                          << "        \"x\" : \"";
                                          
                             reply.sout() << tokens[2];
                             reply.out()  << "\",\n"
                                          << "        \"y\" : \"";
                                          
                             reply.sout() << tokens[6];
                             reply.out()  << "\"\n"
                                          << "        }";
                             start = &str[j+1];
                           }
                         }
                         
                         XFree(str);
                     }
                     reply.out()  << "]\n";
                     reply.out() << "      }\n";

                 }
              }
              reply.out() << "    ]\n";
           }
           else
           {
             reply.out() << "\n";
             log_error("Failed to query the enabled Display Devices.\n\n");
           }
           
        }
        else
        {
            log_error("The NV-CONTROL X extension is not available on screen "
                << screen << " of '" << XDisplayName(NULL) << "'.\n\n");
        }

    }
    else
    {
        log_error("Cannot open display '" << XDisplayName(NULL) << "'.\n\n");
    }

  }
              
  
  reply.out() << "      }"
              << "    },\n"
              << "  \"vdr\" : {\n"
              << "    \"plugin\" : {\n"
              << "      \"graphtft\" : {\n"
              << "         \"enabled\" : " + graphtft_enabled + "\n"
              << "        }\n"
              << "      }\n"
              << "    }\n"
              << "}\n";


/*
 * display_device_name() - return the display device name correspoding
 * to the specified display device mask.
 */

</%cpp>

